<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.6.43">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>langchan</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="langchan_files/libs/clipboard/clipboard.min.js"></script>
<script src="langchan_files/libs/quarto-html/quarto.js"></script>
<script src="langchan_files/libs/quarto-html/popper.min.js"></script>
<script src="langchan_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="langchan_files/libs/quarto-html/anchor.min.js"></script>
<link href="langchan_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="langchan_files/libs/quarto-html/quarto-syntax-highlighting-d4d76bf8491c20bad77d141916dc28e1.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="langchan_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="langchan_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="langchan_files/libs/bootstrap/bootstrap-c0367b04c37547644fece4185067e4a7.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">


</head>

<body class="fullcontent">

<div id="quarto-content" class="page-columns page-rows-contents page-layout-article">

<main class="content" id="quarto-document-content">




<p>AronT-TLV: how do i add sonnet to mycode completion in settings.json</p>
<p>VS Code:</p>
<p>AronT-TLV: <span class="citation" data-cites="vscode">@vscode</span> How do I find settings.json?</p>
<p>VS Code: “type”: “command”, “description”: “Use the <strong>Preferences: Open User Settings (JSON)</strong> command to open your settings.json file directly.”, “details”: { “key”: “workbench.action.openSettingsJson” } }, { “type”: “other”, “description”: “Alternatively, you can press <code>Cmd+,</code> (Command+comma) to open the Settings editor, then click the "Open Settings (JSON)" button in the top-right corner.” }, { “type”: “other”, “description”: “On macOS, the settings.json file is located at: <code>~/Library/Application Support/Code/User/settings.json</code>” }, { “type”: “command”, “description”: “For workspace-specific settings, use <strong>Preferences: Open Workspace Settings (JSON)</strong> command.”, “details”: { “key”: “workbench.action.openWorkspaceSettingsFile” } } ]</p>
<p>AronT-TLV: in the selected line how do i add sonnet 3.7 immersive as my model</p>
<p>GitHub Copilot: # Adding Claude 3.7 Sonnet to GitHub Copilot</p>
<p>To set Claude 3.7 Sonnet as your completion model in GitHub Copilot, modify the <code>github.copilot.selectedCompletionModel</code> setting in your settings.json file:</p>
<pre class="jsonc"><code>"github.copilot.selectedCompletionModel": "claude-3-7-sonnet",</code></pre>
<p>This change will configure GitHub Copilot to use the Claude 3.7 Sonnet model for code completions. After making this change, save the settings.json file and restart VS Code for the changes to take effect.</p>
<p>Note that the exact model identifier (“claude-3-7-sonnet”) depends on GitHub Copilot’s current naming convention, so if you encounter any issues, check VS Code’s GitHub Copilot documentation for the most up-to-date model identifiers.</p>
<p>AronT-TLV: in the chat which ai model am i currently using</p>
<p>GitHub Copilot: You’re currently using Claude 3.7 Sonnet through GitHub Copilot. This is configured in your settings.json file with the setting <code>"github.copilot.selectedCompletionModel": "claude-3-7-sonnet"</code>.</p>
<p>AronT-TLV: i am referring to chat not code completion model</p>
<p>GitHub Copilot: You’re currently using Claude 3.7 Sonnet for GitHub Copilot Chat. This is different from the code completion model setting in your settings.json file, which is also set to “claude-3-7-sonnet”.</p>
<p>The system indicates I’m specifically “Claude 3.7 Sonnet Thinking” - the chat model you’re interacting with right now.</p>
<p>AronT-TLV: how do i set code completion to claude 3.7 thinking</p>
<p>VS Code: “description”: “To enable Claude 3.7 thinking for code completion, add the following setting to your github.copilot.advanced section in settings.json:”, “details”: { “key”: “github.copilot.advanced.thinking”, “value”: true } }, { “type”: “other”, “description”: “You already have the model correctly set to Claude 3.7 Sonnet with ‘github.copilot.selectedCompletionModel’: ‘claude-3-7-sonnet’ and the thinking tool enabled for chat with ‘github.copilot.chat.agent.thinkingTool’: true.” }, { “type”: “other”, “description”: “Make sure to place the new setting inside the github.copilot.advanced object, maintaining proper JSON syntax with commas between entries.” } ]</p>
<p>AronT-TLV: open settings</p>
<p>VS Code: “description”: “Use the <strong>Preferences: Open User Settings</strong> command to open the Settings editor.”, “details”: { “key”: “workbench.action.openSettings” } }, { “type”: “other”, “description”: “You can also press <code>Cmd+,</code> (Command+comma) to open Settings directly.” }, { “type”: “command”, “description”: “To open settings directly in JSON format, use the <strong>Preferences: Open User Settings (JSON)</strong> command.”, “details”: { “key”: “workbench.action.openSettingsJson” } }, { “type”: “other”, “description”: “Alternatively, in the Settings UI, click the "Open Settings (JSON)" button in the top-right corner to switch to the JSON view.” } ]</p>
<p>AronT-TLV: in this chat, can you ingest files i provide that are for example pdf</p>
<p>GitHub Copilot: Yes, I can work with certain types of files you provide in chat, with some limitations:</p>
<p>I can analyze: - Code files (like the Julia notebook you shared) - Plain text files - JSON files - Text-based content from PDFs that you extract and share</p>
<p>For PDFs specifically: - I can’t directly open binary PDF files - I can work with text content you extract and paste from PDFs - I can’t process images or non-text elements within PDFs</p>
<p>If you have PDF content you’d like me to help with, you can extract the relevant text and share it in the chat, and I’ll be able to analyze that content and provide assistance.</p>
<p>AronT-TLV: how do i se5t up an mcp so you can ingest documentation from a website</p>
<p>GitHub Copilot: # Working with External Documentation in GitHub Copilot</p>
<p>GitHub Copilot doesn’t support direct website ingestion for documentation. Here are your options for working with external documentation:</p>
<section id="manual-approaches" class="level2">
<h2 class="anchored" data-anchor-id="manual-approaches">Manual Approaches</h2>
<ol type="1">
<li><p><strong>Copy-Paste Text Content</strong>:</p>
<pre><code>// Copy relevant sections from documentation websites into our chat</code></pre></li>
<li><p><strong>Use Local Files</strong>:</p>
<pre><code>// Save documentation as text/markdown files and upload them to our chat</code></pre></li>
<li><p><strong>Screenshots as Images</strong>:</p>
<pre><code>// For visual documentation, share screenshots (though I can't process complex images)</code></pre></li>
</ol>
</section>
<section id="automation-alternatives" class="level2">
<h2 class="anchored" data-anchor-id="automation-alternatives">Automation Alternatives</h2>
<p>If you need to work with large amounts of documentation:</p>
<ol type="1">
<li><strong>Local Documentation Server</strong>: Set up a local server with the docs</li>
<li><strong>Knowledge Base Solutions</strong>: Consider tools like LangChain or similar for RAG-based systems</li>
<li><strong>VS Code Extensions</strong>: Some extensions support pulling documentation into comments</li>
</ol>
<p>I can’t directly access websites, but I can work with any content you share in our conversation.</p>
<p>AronT-TLV: what do you mean by RAG-based systems</p>
<p>GitHub Copilot: # RAG-Based Systems Explanation</p>
<p>RAG stands for <strong>Retrieval Augmented Generation</strong>, which is an approach that enhances AI models by combining:</p>
<ol type="1">
<li><strong>Retrieval</strong>: Finding relevant information from external knowledge sources (documentation, databases, files)</li>
<li><strong>Augmentation</strong>: Adding this retrieved information to the AI’s context</li>
<li><strong>Generation</strong>: Using the AI to create responses based on both the query and the retrieved information</li>
</ol>
</section>
<section id="benefits-for-documentation" class="level2">
<h2 class="anchored" data-anchor-id="benefits-for-documentation">Benefits for Documentation</h2>
<p>When working with documentation: - The system indexes your documentation in a vector database - When you ask a question, it retrieves relevant documentation sections - Those sections are added to the AI’s context - The AI generates responses grounded in your actual documentation</p>
<p>This helps overcome limitations by providing access to specific knowledge, ensuring up-to-date information, and reducing incorrect responses by grounding answers in your actual content.</p>
<p>Popular frameworks for building RAG systems include LangChain, LlamaIndex, and similar tools.</p>
<p>AronT-TLV: can you work with langchain</p>
<p>GitHub Copilot: # Working with LangChain</p>
<p>Yes, I can help you work with LangChain! LangChain is a framework for building applications powered by language models. I can assist with:</p>
</section>
<section id="what-i-can-help-with" class="level2">
<h2 class="anchored" data-anchor-id="what-i-can-help-with">What I Can Help With</h2>
<ul>
<li><strong>Setting up LangChain</strong>: Installation and basic configuration</li>
<li><strong>Building chains</strong>: Creating sequences of prompts and operations</li>
<li><strong>Document processing</strong>: Loading, chunking, and embedding documents</li>
<li><strong>RAG implementation</strong>: The retrieval-augmented generation systems we discussed earlier</li>
<li><strong>Vector databases</strong>: Working with Chroma, FAISS, Pinecone, etc.</li>
<li><strong>Agents and tools</strong>: Building LLM agents that use tools</li>
</ul>
</section>
<section id="julia-integration" class="level2">
<h2 class="anchored" data-anchor-id="julia-integration">Julia Integration</h2>
<p>Since you’re working with Julia (based on your notebook), I should mention that while LangChain is primarily Python-based, you have options:</p>
<ol type="1">
<li>Use LangChain.jl (community package)</li>
<li>Call Python LangChain through PyCall</li>
<li>Build a separate Python service that your Julia code communicates with</li>
</ol>
<p>Would you like specific guidance on any particular aspect of working with LangChain?</p>
<p>AronT-TLV: can you provide some references (books and wbsites) which will help me understand what langchain is</p>
<p>GitHub Copilot: # LangChain Learning Resources</p>
</section>
<section id="official-documentation" class="level2">
<h2 class="anchored" data-anchor-id="official-documentation">Official Documentation</h2>
<ul>
<li><strong><a href="https://python.langchain.com/docs/get_started/introduction">LangChain Official Documentation</a></strong> - Comprehensive guides, tutorials and API reference</li>
<li><strong><a href="https://github.com/langchain-ai/langchain">LangChain GitHub Repository</a></strong> - Source code and examples</li>
<li><strong><a href="https://docs.langchain.com/docs/">LangChain Conceptual Documentation</a></strong> - Core concepts explanation</li>
</ul>
</section>
<section id="books" class="level2">
<h2 class="anchored" data-anchor-id="books">Books</h2>
<ul>
<li><strong>“Generative AI with LangChain”</strong> by Ben Auffarth</li>
<li><strong>“LangChain for LLM Application Development”</strong> by James Briggs</li>
<li><strong>“Building LLM Powered Applications”</strong> by Umberto Griffo</li>
</ul>
</section>
<section id="online-courses-tutorials" class="level2">
<h2 class="anchored" data-anchor-id="online-courses-tutorials">Online Courses &amp; Tutorials</h2>
<ul>
<li><strong><a href="https://www.deeplearning.ai/short-courses/langchain-chat-with-your-data/">LangChain: Chat with Your Data</a></strong> - DeepLearning.AI course by Harrison Chase (creator of LangChain)</li>
<li><strong><a href="https://www.deeplearning.ai/short-courses/langchain-for-llm-application-development/">LangChain for LLM Application Development</a></strong> - Another course by DeepLearning.AI</li>
</ul>
</section>
<section id="blogs-articles" class="level2">
<h2 class="anchored" data-anchor-id="blogs-articles">Blogs &amp; Articles</h2>
<ul>
<li><strong><a href="https://blog.langchain.dev/">LangChain Blog</a></strong> - Official blog with updates and use cases</li>
<li><strong><a href="https://towardsdatascience.com/search?q=langchain">Towards Data Science - LangChain articles</a></strong></li>
</ul>
</section>
<section id="community-resources" class="level2">
<h2 class="anchored" data-anchor-id="community-resources">Community Resources</h2>
<ul>
<li><strong><a href="https://discord.gg/6adMQxSpJS">LangChain Discord</a></strong> - Community discussion</li>
<li><strong><a href="https://twitter.com/LangChainAI">LangChain Twitter</a></strong> - Latest updates</li>
</ul>
</section>
<section id="julia-integration-1" class="level2">
<h2 class="anchored" data-anchor-id="julia-integration-1">Julia Integration</h2>
<ul>
<li><strong><a href="https://github.com/jkaardal/LangChain.jl">LangChain.jl</a></strong> - Julia implementation (community maintained)</li>
<li>For Julia integration, you might also consider using PyCall to access the Python implementation</li>
</ul>
<p>These resources should give you a comprehensive understanding of what LangChain is and how to use it for building applications with large language models.</p>
<p>AronT-TLV: saave this chat please</p>
<p>GitHub Copilot: # Saving GitHub Copilot Chat Conversations</p>
<p>To save your current GitHub Copilot Chat conversation in VS Code, you have several options:</p>
</section>
<section id="method-1-using-vs-code-commands" class="level2">
<h2 class="anchored" data-anchor-id="method-1-using-vs-code-commands">Method 1: Using VS Code Commands</h2>
<ol type="1">
<li>Click the three dots (⋮) in the top right corner of the chat panel</li>
<li>Select “Save Chat As…” from the dropdown menu</li>
<li>Choose a location and filename to save the conversation</li>
</ol>
</section>
<section id="method-2-keyboard-shortcut" class="level2">
<h2 class="anchored" data-anchor-id="method-2-keyboard-shortcut">Method 2: Keyboard Shortcut</h2>
<ul>
<li>Use the keyboard shortcut <code>Ctrl+S</code> (Windows/Linux) or <code>Cmd+S</code> (Mac) while the chat panel is focused</li>
</ul>
</section>
<section id="method-3-manual-copy" class="level2">
<h2 class="anchored" data-anchor-id="method-3-manual-copy">Method 3: Manual Copy</h2>
<p>If the above methods aren’t available in your version: 1. Select the text in the chat you want to save 2. Copy the content (Cmd+C on Mac) 3. Paste into a new file and save it</p>
<p>The chat will typically be saved as a Markdown (.md) file, preserving the formatting of the conversation.</p>
</section>

</main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>